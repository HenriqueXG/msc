"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@blueprintjs/core");
const styled_blueprintjsx_1 = require("@nteract/styled-blueprintjsx");
const React = __importStar(require("react"));
// https://github.com/jupyter/nbformat/blob/master/nbformat/v4/nbformat.v4.schema.json#L67
const tagStyle = {
    background: "#f1f8ff",
    color: "#0366d6",
    marginRight: "5px"
};
const authorStyle = {
    background: "#E5E5E5",
    fontStyle: "italic",
    marginRight: "5px"
};
const authorStyleBlack = Object.assign({}, authorStyle, { color: "black" });
const addTagMessage = React.createElement("span", null, "Add a tag");
const addAuthorMessage = React.createElement("span", null, "Add an author");
class HeaderEditor extends React.PureComponent {
    constructor(props) {
        super(props);
        this.state = {
            editMode: "none"
        };
    }
    render() {
        // Otherwise assume they have their own editor component
        const { editable, headerData, onChange } = this.props;
        const marginStyles = { marginTop: "10px" };
        const styles = { background: "#EEE", padding: "10px" };
        const onTextChange = (newText) => {
            this.props.onChange(Object.assign({}, headerData, { title: newText }));
        };
        const onEditorChange = (newText) => {
            onChange(Object.assign({}, headerData, { description: newText }));
        };
        const onAuthorsRemove = (t) => (evt, props) => {
            if (editable === true) {
                onChange(Object.assign({}, headerData, { authors: headerData.authors.filter(p => p.name !== t.name) }));
                return;
            }
            return;
        };
        const onTagsRemove = (t) => (e, props) => {
            if (editable) {
                onChange(Object.assign({}, headerData, { tags: headerData.tags.filter(p => p !== t) }));
                return;
            }
            return;
        };
        const onTagsConfirm = (e) => {
            onChange(Object.assign({}, headerData, { tags: [...headerData.tags, e] }));
            this.setState({ editMode: "none" });
        };
        const onAuthorsConfirm = (e) => {
            onChange(Object.assign({}, headerData, { authors: [...headerData.authors, { name: e }] }));
            this.setState({ editMode: "none" });
        };
        const onCancel = () => this.setState({ editMode: "none" });
        const onClick = () => this.setState({ editMode: "author" });
        const onAdd = () => this.setState({ editMode: "tag" });
        return (React.createElement("header", null,
            React.createElement("div", { style: styles },
                React.createElement(core_1.H1, null,
                    React.createElement(core_1.EditableText, { value: headerData.title, placeholder: "Edit title...", disabled: !editable, onChange: onTextChange })),
                React.createElement("div", null,
                    headerData.authors.length <= 0 ? null : "By ",
                    headerData.authors.map(t => (React.createElement(core_1.Tag, { key: t.name, large: true, minimal: true, style: authorStyle, onRemove: onAuthorsRemove(t) }, t.name))),
                    (this.state.editMode === "author" && (React.createElement(core_1.Tag, { style: authorStyleBlack },
                        React.createElement(core_1.EditableText, { maxLength: 40, className: "author-entry", placeholder: "Enter Author Name...", selectAllOnFocus: true, onConfirm: onAuthorsConfirm, onCancel: onCancel })))) || (React.createElement(core_1.Tooltip, { content: addAuthorMessage, position: core_1.Position.RIGHT, usePortal: false, disabled: !editable },
                        React.createElement(core_1.Button, { icon: "add", className: "author-button", onClick: onClick, minimal: true, disabled: !editable })))),
                React.createElement("div", null,
                    headerData.tags.map(t => (React.createElement(core_1.Tag, { key: t, style: tagStyle, onRemove: onTagsRemove }, t))),
                    (this.state.editMode === "tag" && (React.createElement(core_1.Tag, { style: tagStyle },
                        React.createElement(core_1.EditableText, { maxLength: 20, placeholder: "Enter Tag Name...", selectAllOnFocus: true, onConfirm: onTagsConfirm, onCancel: onCancel })))) || (React.createElement(core_1.Tooltip, { content: addTagMessage, position: core_1.Position.RIGHT, usePortal: false, disabled: !editable }, React.createElement(core_1.Button, { icon: "add", minimal: true, onClick: onAdd, disabled: !editable })))),
                React.createElement("div", { style: marginStyles },
                    React.createElement(core_1.EditableText, { maxLength: 280, maxLines: 12, minLines: 3, multiline: true, placeholder: "Edit description...", selectAllOnFocus: false, value: headerData.description, disabled: !editable, onChange: onEditorChange }))),
            React.createElement(styled_blueprintjsx_1.BlueprintCSS, null)));
    }
}
HeaderEditor.defaultProps = {
    editable: true,
    headerData: {
        authors: [],
        description: "",
        tags: [],
        title: ""
    },
    // tslint:disable no-empty
    onChange: () => { },
    onRemove: (e, props) => { },
    theme: "light"
};
exports.HeaderEditor = HeaderEditor;
